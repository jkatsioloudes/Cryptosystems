PSK
http://www.internet-computer-security.com/VPN-Guide/PSK.html

PSK is a key both peers use to identify themselves to each other. If one pre-shared key is different from the other, then the authentication will not be successful. In a real world scenario you would specify this on a VPN Gateway at one site, such as a firewall with VPN capabilities and then specify the exact same key on the other site’s VPN Firewall. So it is a way for a device to prove it is authorised by providing a pre-shared key identical to the opposite peer in negotiation.

Pre shared keys are easier to configure than digital certificates, and are typically used for small to medium sized businesses that require a VPN connection. You would usually communicate a pre-shared key via the phone or in person so that it is not captured by anyone such as a hacker sniffing the network.

You would then specify your pre-shared key within your VPN configurations, and do the same at the peer end. A VPN gateway should use long Pre-shared keys to eliminate chances of being hacked, 10 plus characters is recommended. For large networks though, digital certificates should be implemented over pre-shared keys as digital certificates are scalable.


X509
https://www.embedded.com/electronics-blogs/say-what-/4442799/IoT-security--when-X-509-certificate-authentication-may-not-work

In cryptography, X.509 is an important standard for a public key infrastructure (PKI) to manage digital certificates and their associated public key for asymmetric encryption (public-key encryption). X.509 is a key component in the Transport Layer Security (TLS/SSL) protocol -- a security layer used to secure many IoT protocols.

The TLS protocol requires the server to have an X.509 certificate; however, an X.509 certificate is optional for the client. The server certificate enables the client to authenticate the server and enables the TLS protocol to setup a secure (encrypted) communication channel with the server. A client certificate, in addition, enables the server to authenticate the client. This is known as mutual authentication, where the client authenticates the server (required) and the server authenticates the client (optional).

From an authentication perspective, X.509 certificates undeniably make a solution more secure, However, using X.509 certificate authentication greatly complicates a design if client-side certificates are required.

As was mentioned above, a client-side certificate enables the server to authenticate the client and can be used by the server to uniquely identify each client connected to an IoT solution. Creating a unique X.509 Certificate and the corresponding private key for each device greatly increases the complexity in the manufacturing process. When these certificates are created, they must be signed by a Certificate Authority (CA). To automate the manufacturing process, the CA certificate and the corresponding CA certificate's private key must be available during the manufacturing process. Exposing the CA certificate's private key to anyone outside your organization is a major security issue. Therefore, the CA certificate's private key should be locked up in a vault with only specified individuals having access to it.

A server must implement what is known as a certificate revocation list since it may be possible for a hacker to extract the certificate/private key pair from a device and to use this key to compromise an IoT solution. The revocation list includes the certificate's serial number of all certificates that have been exploited. For this to work, you must first find a way to detect non-conforming devices connecting to your IoT solution and then add the certificate's serial number to the revocation list. A non-conforming device could be one where a hacker that has managed to extract an X.509 certificate and the corresponding private key from a device and is then using this certificate for gaining access to the IoT solution. Such detection is very difficult.

In addition, X.509 certificates include an expiration date making it mandatory for IoT solutions to update the certificate from time to time.

As you can see, using client-side X.509 certificate authentication from an administrative perspective may be very difficult to deploy. This is likely the reason most existing solutions are based on using the same X.509 certificate/private key in all devices. SEC consult, an information security advisor, has published two reports: the first shows how industry-wide HTTPS certificate and SSH key reuse endangers millions of devices worldwide, while an updated report only nine months later revealed that such reuse had increased by 40%, further illustrating the growth in incorrect X.509 certificate authentication usage.


PSK Vs Certificate
https://security.stackexchange.com/questions/165546/pre-shared-public-key-vs-certificate

Let's compare the workflows of the two processes, specifically how the handle key compromise.
Pre-shared Secret

The server generates a keypair, you copy this to every client machine (manually, through a script, etc). When connecting to the server, the client will check that the public key presented matches the one they have cached for that server (conceptually, this is the same as SSH's fingerprint id method).

Upside: no need for the inconvenience of getting a CA-signed certificate. You can generate the server's keypair and start deploying it to clients immediately.

Downside: Recovering from a key compromise is difficult or impossible because there is no mechanism for the server to notify clients of a key compromise, except by pushing a new keypair to all clients. Consider that an attacker has the server's private key and can intercept traffic between the client and server (both to block the updated keypair push, and to man-in-the-middle the client's connection to the server). The client will trust the attacker and believe that it is talking to the authentic server and there is nothing you can do to prevent this because at a fundamental level, pre-shared secrets have no revocation mechanism.
Certificate

Yes, it's annoying (and sometimes expensive) to get a certificate, but the trust no longer depends on your ability to push the pre-shared key to the clients.

Part of the validation process for a certificate is for the client to reach out to the CA and ensure that the certificate is not revoked and if it fails to reach the CA, this counts as a failure. Spoofing this revocation check requires the attacker to compromise not only the server's private key, but the CA's private key as well. If the server realizes that it's keypair has been compromised and asks the CA to revoke it, all clients will know immediately because the online revocation checks will fail.

Revocation is the main reason to use certificates here, but also consider that an attacker can intercept the initial public key push and replace it with their own public key. Maybe you are the network admin and can guarentee to deploy the public keys securely, but certificates make this a moot point because even if the attacker can intercept the certificate deployment, spoofing a cert requires compromising the CA.


Same question from https://community.cisco.com/t5/other-security-subjects/pre-shared-key-vs-certificate-is-which-best-and-why/td-p/61160

In security point of view, using CA server and certificate will add more security to your VPN network, that is for sure. Certificate has much longer public and private key then pre-shared. Certificate is not easy to be exported, once the laptop has been stolen, you can revoke the certificate from the Cert server.

If you are using pre-shared key, you need change all other PC's group password in case someone get he group password from the stolen PC.

If you have more than 10 LAN to LAN sites, using certificate can make the configuration simpler, because you do not need to config pre-shared keys for each site.Use same Cert server and enroll all the routers to it , then it will be done.

***

*For the remote access point of view, You need enroll all your clients(depending or username or PC), each client will have one certificate. If you have several hundreds of users, that will increase your workload for sure.*


Same question from https://security.stackexchange.com/questions/48882/advantage-mutual-authentication-over-psk

"Pre-shared key" is indeed a valid model, and simple, if you can pull it off. Asymmetric cryptography, with public and private keys, and certificates, was invented to solve the secret key distribution problem: in general, it is hard to ensure that all pairs of systems/people who must securely talk to each other actually share a secret value. In a client-server setup, where client and server are distinct machines, then a shared secret must necessarily have travelled from one machine to the other. Travelling secrets are "less secret". With asymmetric cryptography, only public values actually go over the wires; private keys can remain local through their complete life cycle, and that's usually a good idea.

Similarly, if client and server share the same secret value, then an attacker hijacking either machine learns the secret and can impersonate both. With asymmetric cryptography, an attacker who plunders the RAM or disk of the client can later on connect to the server and authenticate as a client, but cannot run a fake server which would fool the client.

These are reasons why a pre-shared key mechanism, though tempting (it is lighter on CPU, and involves none of the dreaded X.509/CA business), make in practice imply some weaknesses, depending on how the system is installed and maintained.

(Of course, in all of the above I suppose that you do not do anything stupid, such as having a shared "secret" between the server and 10000 clients; if 10000 clients know a "secret" then it no longer is a secret. Appropriate pre-shared key systems use a different key for each client-server pair. When the pre-shared key is a human-remembered secret, i.e. a password, then extra care must be employed, because passwords are weak.


CA Hierarchy
full text here: https://sites.google.com/site/ddmwsst/digital-certificates

CAs are hierarchical in structure. There are generally three types of hierarchies, and they are denoted by the number of tiers.

Single/One Tier Hierarchy

A single tier Hierarchy consists of one CA. The single CA is both a Root CA and an Issuing CA. A Root CA is the term for the trust anchor of the PKI. Any applications, users, or computers that trust the Root CA trust any certificates issued by the CA hierarchy. The Issuing CA is a CA that issues certificates to end entities. For security reasons, these two roles are normally separated. When using a single tier hierarchy they are combined. 

Two Tier Hierarchy

A two tier hierarchy is most common. In some ways it is a compromise between the One and Three Tier hierarchies. In this design there is a Root CA that is offline, and a subordinate issuing CA that is online. The level of security is increased because the Root CA and Issuing CA roles are separated. But more importantly the Root CA is offline, and so the private key of the Root CA is better protected from compromise. It also increases scalability and flexibility. This is due to the fact that there can be multiple Issuing CA’s that are subordinate to the Root CA. This allows you to have CA’s in different geographical location, as well as with different security levels. 

Three Tier Hierarchy

Specifically the difference between a Two Tier Hierarchy is that second tier is placed between the Root CA and the issuing CA. The placement of this CA can be for a couple different reasons. The first reason would be to use the second tier CA as a Policy CA. In other words the Policy CA is configured to issue certificates to the Issuing CA that is restricted in what type of certificates it issues. The Policy CA can also just be used as an administrative boundary. In other words, you only issue certain certificates from subordinates of the Policy CA, and perform a certain level of verification before issuing certificates, but the policy is only enforced from an administrative not technical perspective.

The other reason to have the second tier added is so that if you need to revoke a number of CAs due to a key compromise, you can perform it at the Second Tier level, leaving other “branches from the root” available. It should be noted that Second Tier CAs in this hierarchy can, like the Root, be kept offline.


Chain/Hierarchy of Trust
https://docs.microsoft.com/en-us/windows/desktop/seccrypto/hierarchy-of-trust

For digital certificates to be effective, users of certificates must have a high level of trust in them. There are cases where a user does not trust the issuer of a certificate. This could happen if the certificate user has never heard of the certification authority and therefore is uncomfortable with accepting a certificate from that issuer at face value. This problem is addressed in the certifying process by a hierarchy of trust.

A hierarchy of trust begins with at least one certification authority that is trusted by all entities in the certificate chain. This can be an internal certification authority administrator or an external company or organization that specializes in verifying identities and issuing certificates. This authority is called the root authority. The root authority then certifies other certification authorities, called first-tier certification authorities, who can then issue certificates and also certify additional or second-tier certification authorities. This situation is shown in the following illustration.

The identity of the certification authority issuing a certificate is part of a certificate. That certification authority is called the certificate's issuer. When a certificate's issuer is a tier 1 or tier 2 certification authority, the receiver of that certificate can determine whether the certificate's issuer is certified as a valid certification authority by a certification authority at a level above it, and that the higher level certification authority is certified as a valid certification authority by still a higher level certification authority until it is determined that a chain of trust exists between the lowest level certification authority and the root certification authority.


The advantages of using a two-tier certificate authority hierarchy
http://blogs.microsoft.co.il/yuval14/2013/08/16/the-benefits-of-two-level-certificate-authority-hierarchy/

1. Performance & Scalability & Redundancy

Using multiple Subordinate CA/Intermediate CA allow the organization to split the load of processing of PKI tasks to multiple

server. By using multiple Subordinate CA/Intermediate CA the organization can provides answer to a common scenarios like:

a. Failure of one (or more) Subordinate CA/Intermediate CA server wouldn’t reduce the availability of the PKI service in the organization.

b. By installing Subordinate CA/Intermediate CA in each Active Directory site, users and/or computers digital certificates would be issue/renew from the nearest Subordinate CA/Intermediate CA & not over slow WAN lines.

c. By installation multiple Subordinate CA/Intermediate CA the total load on each Subordinate CA/Intermediate CA would be reduced. Reducing the load of each Subordinate CA/Intermediate CA would allow the the organization to answer to the SLA (Service Level Agreement) requirements for issue & renewing digital certificates.

2. Legalization

In many organizations using PKI for common legal tasks, like signing documents, allow SSL/TLS access for payment systems, etc..

Usually each organization publish two legal documents to his customers/end users that cover legal & service issues:

-Certificate policy (CP)

-Certificate practice statement (CPS)

Each CA can contain only a single Certificate policy (CP) document & a single Certificate practice statement (CPS) document.

In case that the organization need to publish a multiple versions of Certificate policy (CP) document & a a multiple versions Certificate practice statement (CPS) document – additional Subordinate CA/Intermediate CA would be needed.

3. Auditing

In case that a separate Auditing may need to implemented, using a multiple Subordinate CA/Intermediate CA may allow you to answer to this requirement. 

4. SOD – Separation Of Duties

By using multiple Subordinate CA/Intermediate CA the organization can provides answer to a common scenarios like:

a. Allow each IT team to mange his unique Subordinate CA/Intermediate CA.

b. Reduce the exposure of each IT team to digital certificates that shouldn’t be manage by this IT team.

c. Allow each Subordinate CA/Intermediate to use only a specific Certificate Templates.

5. Reducing the impact of compromise Subordinate CA/Intermediate CA / Subordinate CA/Intermediate CA theft

By using multiple Subordinate CA/Intermediate CA the organization the impact of compromise Subordinate CA/Intermediate CA and/or Subordinate CA/Intermediate CA theft – may be less drastic to the organization.


notes-on-ipsec (ipsec) Vs create-x509.sh (openssl)
I have noticed that the difference is the commands openssl and ipsec whereas the logic followed is similar including the creation/generation of a private key, then certificate, signing of certifiate from the corresponding hierarchy.  However, what is the difference between ipsec and opensll?

First things first: OpenSSL is an open source implementation of the SSL and TLS protocols.

Q: 
https://stackoverflow.com/questions/4952339/ipsec-vs-openssl-vs-pgp

IPSec is employed at the IP level, SSL at the transport level and PGP at the application level. In some lecture not it says:
IPSEC: Most general solution but least flexible SSL: Still very general and some flexibility PGP: Least general but very flexibel.
I guess the general refers to what kind of protocol I can secure. With IPSEC I can secure everything that uses TCP or UDP. PGP is the least general because it just encrypts emails and is therefore very specific. Is that understanding right?
However I have no idea for what the flexibilty refers in this context, anyone an idea? Has this to do with extensibility?

A:
IPSEC: Its an Internet layer protocol, which means anything that runs above the IP layer, such as TCP or UDP for example, or any other newer protocol, will be encrypted by IPSEC. Now however, it is a protocol for encryption/authentication of the packets/protocol above it and only this, thus its less flexible in SOME sense compared to the other two but its still fairly flexible if you need network encryption.

SSL: Is another encryption protocol, similar (I guess) to IPSEC, however it operates at a higher layer than IPSEC. Basically it operates on the Application layer which means it is a protocol that runs on top of TCP, UDP, etc...

Now one problem with IPSEC is that its flexible in some respect in that its lower in the network layer, however this also poses problem in that devices needs to support IPSEC protocol itself, and often cheap consumer routers don't. So in a sense SSL would be more flexible than IPSEC because it operates on a higher layer.

PGP: Is a completely different domain from SSL/IPSEC, because SSL/IPSEC restricts their-selves to network encryption, they don't deal with encryption of files or any other data, all they deal with is the encryption of "bytes" that are going over the network and once the other end has read in the bytes its going to be sitting there unencrypted.

Now PGP is an application/standard that you can use to encrypt files with your destination public key and then only the destination's private key can decrypt the file. Anyway you can encrypt a file, email, or what so ever then transport it over the network to the destination and it would achieve the same thing. But on the other hand you can also store the file on disk encrypted or copy it to an external harddrive for example, and walk down the hallway and give it to your destination.

So in summary IPSEC/SSL are somewhat roughly equivalent, they run on different network layers, and PGP is an entirely different domain from IPSEC/SSL but you can still use PGP to encrypt some piece of data and then transfer it over the network.

So really in the sense of flexibility, especially in the PGP context is in that you can use it for other things such as storing encrypted files on disk, or can use your private key to sign some piece of documentation/file and anyone can use your public key to prove that it came from you.

A:
Every encryption protocol only works if you have support at both ends.

SSL was the easiest to deploy, because it was built into the browsers and the web servers. For the most part, everybody who wanted to run a web server already had SSL support built-in---they just had to be technically savvy to turn it on (and to purchase a cert or willing to live with a warning to the end user.

One of the nice things about SSL is that it has key-management built in.

IPSEC does provide host-to-host encryption. However the underlying design was so flexible that multiple IPSEC systems couldn't communicate with either other unless they were identically configured. Worse, key management wasn't part of the protocol for many years. Even there there were grand plans for systems that automatically recognized that there were IPSEC-enabled systems on both ends and automatically engaged, this never worked (still doesn't work).

PGP is a static message encryption system. It doesn't encrypt stuff that's interactive. And you shouldn't use PGP, you should use S/MIME, as its already integrated into Apple Mail, Evolution, Outlook Express, Outlook, Thunderbird, etc.

So yes, IPSEC would be a better choice, but it's too hard to use. PGP doesn't do enough. SSL hit the sweet spot, which is why it dominates.


Q:
https://security.stackexchange.com/questions/63330/are-there-any-reasons-for-using-ssl-over-ipsec

Reasons for using SSL over IPSec

A:
There are different layers of secure transport to consider here:

VPNs
SSL VPN (including tunnels)
IPSec VPN
SSL/TLS for individual services
IPSec vs SSL VPNs

Both SSL and IPSec VPNs are good options, both with considerable security pedigree, although they may suit different applications.

IPsec VPNs operate at layer 3 (network), and in a typical deployment give full access to the local network (although access can be locked down via firewalls and some VPN servers support ACLs). This solution is therefore better suited to situations where you want remote clients to behave as if they were locally attached to the network, and is particularly good for site-to-site VPNs. IPSec VPNs also tend to require specific software supplied by the vendor, which is harder to maintain on end-user devices, and restricts usage of the VPN to managed devices.

SSL VPNs are often cited as being the preferred choice for remote access. They operate on layers 5 and 6, and in a typical deployment grant access to specific services based on the user's role, the most convenient of which are browser-based applications. It is usually easier to configure an SSL VPN with more granular control over access permissions, which can provide a more secure environment for remote access in some cases. Furthermore, SSL/TLS is inherently supported by modern devices, and can usually be deployed without the need for specialist client-side software, or with lightweight browser-based clients otherwise. These lightweight clients can often also run local checks to ensure that connecting machines meet certain requirements before they are granted access - a feature that would be much harder to achieve with IPSec.

In both cases one can be configured to achieve similar things as the other - SSL VPNs can be used to simply create a tunnel with full network access, and IPSec VPNs can be locked-down to specific services - however it is widely agreed that they are better suited to the above scenarios.

However, for exactly these reasons, many organisations will use a combination of both; often an IPSec VPN for site-to-site connections and SSL for remote access.

There are a number of references on the subject of SSL vs IPSec (some of these are directly from vendors):

https://supportforums.cisco.com/document/113896/quick-overview-ipsec-and-ssl-vpn-technologies
http://netsecurity.about.com/cs/generalsecurity/a/aa111703.htm
http://www.sonicwall.com/downloads/EB_Why_Switch_from_IPSec_to_SSL_VPN.pdf
http://searchsecurity.techtarget.com/feature/Tunnel-vision-Choosing-a-VPN-SSL-VPN-vs-IPSec-VPN
http://www.networkworld.com/article/2287584/lan-wan/ipsec-vs--ssl-vpns.html
End-to-End Encryption

In some of the above cases, such as IPSec VPNs and SSL VPN tunnels, you may not be getting end-to-end encryption with the actual service you're using. This is where using an additional layer of SSL/TLS comes in handy.

Say you're remote and trying to connect to an internally hosted web application via an IPSec VPN. If you use the HTTP protocol via your browser, your traffic is encrypted whilst it is running through the VPN tunnel itself, but it is then decrypted when it hits the remote VPN endpoint, and travels over the internal network in cleartext. This might be acceptable in some use cases, but in the interest of defence in depth, we ideally want to know that our data cannot be intercepted anywhere between you and the actual service itself. By connecting to this application over HTTPS, you effectively have two layers of security: one between you and the VPN endpoint, and another travelling through that (between you and the web server itself).

Of course, this is not limited to HTTPS - you should equally employ other secure protocols like SSH, FTPS, SMTP with STARTTLS etc etc.


Q: 
https://stackoverflow.com/questions/3747584/openssl-vs-ipsec

Just a very general question, but can somebody tell me when I use openSSL and when IPSEC to secure data transfer over the internet? It seems both of them are doing the same, only at different levels of the network protocol. So I am not absolutely sure why we need both of them.  Cheers for your help

A: 
IPSec is based on a configuration file that runs in the background and encrypts all the data between two machines. This encryption is based on IP pairs, an initiator and a responder (at least that's the configuration they use at my workplace, which more or less conforms to the standards). ALL the IP traffic between the two machines is then encrypted. Neither the type nor the content of the traffic is shown. It has its own encapsulation that encapsulates the WHOLE packet (including all the headers that the packet previously had). The packet is then decapsulated (if that's a word) at the other end to get a fully formed packet (not just the payload). The encryption might be using the encryption provided by SSL (e.g. OpenSSL).

SSL, on the other hand, encrypts the data and then you can do what ever you want with it. You can put it on a USB and then give it to someone or just keep it encrypted locally to prevent data theft or send it over the internet or a network (in which case the packet itself won't be encrypted, only the payload, which will be encrypted by SSL).

A: 
Yes, different levels of the network protocol. One is implemented in the OS and the other in an application.
So the reason that both are needed:
- IPSEC can secure all traffic including that from applications that don't use encryption. But, both sides must use an OS that supports IPSEC and must be configured by the system administrator.
- SSL can secure the traffic for one application. It does not need to use a particular OS and it does not need administrator access permissions to configure it.

A: 
You are getting it all wrong buddy...IPSEC is required for a secure communication between two machines.

Like you want to send a packet to other machine but you want that no one could possibly even determine what protocol you are using (tcp/udp.. etc) then you use this IPSEC. and it is not all over there is so much to explore about IPSEC.  openssl is you can say just a encrytion/authentication functions library.  

A clear difference could be understood wh a little example.  Suppose you want to secure traffic between two machines so you create secure encrypted packet , send it to other machine there it needs to be decrypted based on security associations.All this is part of IPSEC Protocol.  While when encrypting the packet on your sending machine you may have used some C/Linux functions to encrypt the packet.This is where openssl comes in place.  Similarly on the other end when you will capture the packet and extract the required part then you can decrypt it using openssl function used on your machine.


IPSEC vs SLL in real life

https://www.lifewire.com/vpns-ipsec-vs-ssl-2486720

Traditional IPSec VPNs
Traditional VPN’s rely on IPSec (Internet Protocol Security) to tunnel between the two endpoints. IPSec works on the Network Layer of the OSI Model- securing all data that travels between the two endpoints without an association to any specific application. When connected on an IPSec VPN the client computer is “virtually” a full member of the corporate network- able to see and potentially access the entire network.

The majority of IPSec VPN solutions require third-party hardware and/or software. In order to access an IPSec VPN, the workstation or device in question must have an IPSec client software application installed. This is both a pro and a con.

The pro is that it provides an extra layer of security if the client machine is required not only to be running the right VPN client software to connect to your IPSec VPN, but also must have it properly configured. These are additional hurdles that an unauthorized user would have to get over before gaining access to your network.

The con is that it can be a financial burden to maintain the licenses for the client software and a nightmare for tech support to install and configure the client software on all remote machines- especially if they can’t be on site physically to configure the software themselves.

SSL VPNs
It is this con which is generally touted as one of the largest pros for the rival SSL (Secure Sockets Layer) VPN solutions. SSL is a common protocol and most web browsers have SSL capabilities built in. Therefore almost every computer in the world is already equipped with the necessary “client software” to connect to an SSL VPN.

Another pro of SSL VPN’s is that they allow more precise access control. First of all they provide tunnels to specific applications rather than to the entire corporate LAN. So, users on SSL VPN connections can only access the applications that they are configured to access rather than the whole network. Second, it is easier to provide different access rights to different users and have more granular control over user access.

A con of SSL VPN’s though is that you are accessing the application(s) through a web browser which means that they really only work for web-based applications. It is possible to web-enable other applications so that they can be accessed through SSL VPN’s, however doing so adds to the complexity of the solution and eliminates some of the pros.

Having direct access only to the web-enabled SSL applications also means that users don’t have access to network resources such as printers or centralized storage and are unable to use the VPN for file sharing or file backups.

SSL VPN’s have been gaining in prevalence and popularity; however they are not the right solution for every instance. Likewise, IPSec VPN’s are not suited for every instance either. Vendors are continuing to develop ways to expand the functionality of the SSL VPN and it is a technology that you should watch closely if you are in the market for a secure remote networking solution. For now, it is important to carefully consider the needs of your remote users and weigh the pros and cons of each solution to determine what works best for you.


CREATE X509 USING OPENSSL AND/OR IPSEC? 
Seems like yes, given that there is a way to generate certificates using openssl (the internet is full of those) bu t also ways through StrongSwan.

https://stackoverflow.com/questions/256405/programmatically-create-x509-certificate-using-openssl

You'll need to familiarize yourself with the terminology and mechanisms first.

An X.509 certificate, by definition, does not include a private key. Instead, it is a CA-signed version of the public key (along with any attributes the CA puts into the signature). The PEM format really only supports separate storage of the key and the certificate - although you can then concatenate the two.

In any case, you'll need to invoke 20+ different functions of the OpenSSL API to create a key and a self-signed certificate. An example is in the OpenSSL source itself, in demos/x509/mkcert.c

For a more detailed answer, please see Nathan Osman's explanation below.


StrongSwan

https://wiki.strongswan.org/projects/strongswan/wiki/IntroductiontostrongSwan

strongSwan is a complete IPsec solution providing encryption and authentication to servers and clients.
It can be used to secure communications with remote networks, so that connecting remotely is the same as
connecting locally

This paragraph was interesting once everything is set up:

The mentioned distinction between policies and SAs often leads to misconceptions. For instance, referring to the image
above, if host moon has a site-to-site tunnel to host sun (connecting the two networks 10.1.0.0/24 and 10.2.0.0/24),
and host carol has a roadwarrior connection to host sun (from which carol received a virtual IP address of 10.3.0.10),
then carol wont be able to automatically communicate with alice, even if forwarding is enabled on sun. This is because
there is no IPsec policy allowing traffic between carol (10.3.0.10) and alice (10.1.0.10). An additional SA between moon
and sun, connecting the virtual subnet 10.3.0.0/24 with 10.1.0.0/24 would be a possible solution to this issue.

Generally, IPsec processing and routing are two different topics. IPsec is often just bumped into the stack (policy based)
and the original routing decision for the unprotected packet also applies to the protected packet.
This is the reason charon, by default, installs specific routes to the remote part of the TS (in newer versions of charon (>5.5.0),
routes aren't installed for transport mode CHILD_SAs).
An exception to this is route based IPsec, which uses interfaces to control what packets are going to be
processed by each tunnel to a unique participant. Route based IPsec is less flexible
than policy based IPsec.


strongSwan provides several methods to do this:

- Public Key Authentication: 
This uses RSA or ECDSA X.509 certificates to verify the authenticity of the peer.
Certificates can be self-signed, in which case they have to be installed on all peers, or signed by a common
Certificate Authority (CA). The latter simplifies deployment and configuration a lot as the gateway only
needs the CA certificate to authenticate all peers that provide a valid certificate signed by that CA.
Certificate Revocation Lists (CRLs) or the Online Certificate Status Protocol (OCSP) may be
used to verify the validity of certificates.

To securely store private keys smart cards may be used via the PKCS#11 plugin.
In order to prevent man-in-the-middle attacks the identity claimed by the peer has to be confirmed by
the certificate, either by the subject or a subjectAltName extension.

- Pre-Shared-Key (PSK): 
A pre-shared-key is an easy to deploy option but it requires strong secrets to be secure.
If the PSK is known to many users (which is often the case with IKEv1 XAuth with PSK) any user who knows
the secret could impersonate the gateway. Therefore this method is not recommended for large scale
deployments.


STRONGSWAN'S PKI

To use certificate based authentication you'll need to create either self-signed certificates or setup a whole public-key
infrastructure (PKI), consisting of a Certificate Authority (CA), optional intermediate CAs and end-entity certificates plus
certificate revocation lists (CRL) or other methods like OCSP to verify the validity of certificates.

One of the easiest ways to generate certificates is to use the ipsec pki utility. Since setting up a whole PKI can be quite
complex, we only provide instructions to get you started.

OpenSSL is also a widespread alternative to generate certificates, as are several GUI based CA management utilities.
Commercial CA management tools like Microsoft's are also often used for large scale CAs.

The generated leaf (end) certificates need to authenticate the corresponding peer's IKE ID for authentication to succeed.


Perfect Forward Secrecy (PFS)

PFS is a must have for every IPsec tunnel. Using PFS will make the endpoints negotiate a new key for each IKE and/or IPsec SA upon rekey or reauthentication event. This protects the confidentiality of the traffic, if the IKE shared secret is leaked. Note, that the keys of the first SA of a new IKEv2 connection are derived from the IKE shared secret. However, subsequent SAs will use new keys if PFS is used.

PFS for strongSwan 5.x onwards is enabled by appending a DH group to the ESP or AH cipher settings. Using PFS introduces no significant performance overhead, unless you rekey more than 80 IPsec SAs per second. Refer to this document for the crypthographic strength and public key handshake speed on some example hardware.

Configurations:	[done] following the approach of having dpdaction=restart for roadwarriors and router.
https://wiki.strongswan.org/projects/strongswan/wiki/UsableExamples

Virtual IP:
https://wiki.strongswan.org/projects/strongswan/wiki/VirtualIP


SecurityRecommendations

User Document:	
https://wiki.strongswan.org/projects/strongswan/wiki/UserDocumentation#HOWTOs

IPsec conf:
https://wiki.strongswan.org/projects/strongswan/wiki/ConnSection
https://wiki.strongswan.org/projects/strongswan/wiki/ConfigSetupSection

ipsec:
https://wiki.strongswan.org/projects/strongswan/wiki/IpsecCommand

strong4.2conf:	
https://www.strongswan.org/docs/readme4.htm#section_2.6


Leftsendcert=always is a result of https://www.strongswan.org/docs/readme4.htm#section_5.7 from not achieving a correct connectivity with the =never
option.


